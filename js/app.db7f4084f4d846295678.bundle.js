(self.webpackChunk=self.webpackChunk||[]).push([[143],{138:(e,t,n)=>{const s=n(475),a=n(27),o=new Array(20).fill(0).map(((e,t)=>({title:`Ch ${t+1}`}))),{lightningChart:i,AutoCursorModes:r,emptyLine:l,AxisTickStrategies:c,AxisScrollStrategies:h,synchronizeAxisIntervals:g,UIOrigins:d,UIDraggingModes:m,Themes:u}=s,{createProgressiveFunctionGenerator:M}=a,p=document.getElementById("chart")||document.body,f=document.createElement("div");p.append(f),f.style.width="100%",f.style.height="1400px",f.style.display="flex",f.style.flexDirection="column";const y=i(),S=o.map(((e,t)=>{const n=document.createElement("div");f.append(n),n.style.height="20vh";const s=y.ChartXY({container:n}).setTitle("").setPadding({top:0,bottom:0}).setAutoCursorMode(r.disabled).setBackgroundStrokeStyle(l).setMouseInteractions(!1),a=s.getDefaultAxisX().setTickStrategy(c.Empty).setStrokeStyle(l).setScrollStrategy(h.progressive).setInterval({start:-1e4,end:0,stopAxisAfter:!1}),o=s.getDefaultAxisY().setTickStrategy(c.Empty).setStrokeStyle(l).setTitle(e.title).setTitleRotation(0).setThickness(60),i=s.addLineSeries({dataPattern:{pattern:"ProgressiveX",regularProgressiveStep:!0},automaticColorIndex:t}).setName(`Channel ${t+1}`).setDataCleaning({minDataPointCount:1e4}).setStrokeStyle((e=>e.setThickness(-1)));return{chart:s,series:i,axisX:a,axisY:o}})),x=S[0],I=S[S.length-1];x.chart.setTitle(`Multi-channel real-time monitoring (${o.length} chs, 1000 Hz)`);const k=I.axisX.setTickStrategy(c.Time,(e=>e.setMajorTickStyle((e=>e.setGridStrokeStyle(l))).setMinorTickStyle((e=>e.setGridStrokeStyle(l)))));g(...S.map((e=>e.axisX))),k.setNibInteractionScaleByDragging(!1).setNibInteractionScaleByWheeling(!1).setAxisInteractionZoomByWheeling(!1);const A=(e,t)=>{const n=k.getInterval(),s=n.end-n.start,a=s+.1*Math.sign(t.deltaY)*Math.abs(s);k.setInterval({start:n.end-a,end:n.end,stopAxisAfter:!1}),t.preventDefault(),t.stopPropagation()};k.onAxisInteractionAreaMouseWheel(A),S.forEach((e=>{e.chart.onSeriesBackgroundMouseWheel(A),e.series.onMouseWheel(A)})),S[S.length-1].chart.addUIElement().setText("Reset").setPosition({x:0,y:0}).setOrigin(d.LeftBottom).setMargin({left:4,bottom:4}).setDraggingMode(m.notDraggable).onMouseClick((e=>{const t=S[0].series.getXMax();k.setInterval({start:t-1e4,end:t,stopAxisAfter:!1}),S.forEach((e=>e.axisY.fit()))}));const w=[{length:400*Math.PI,func:e=>Math.sin(e/200)},{length:400*Math.PI,func:e=>Math.cos(e/200)},{length:800*Math.PI,func:e=>Math.cos(e/400)+Math.sin(e/200)},{length:800*Math.PI,func:e=>Math.sin(e/100)+Math.cos(e/400)},{length:800*Math.PI,func:e=>Math.sin(e/200)*Math.cos(e/400)},{length:1800*Math.PI,func:e=>Math.cos(e/900)},{length:3200*Math.PI,func:e=>Math.sin(e/1600)},{length:2600*Math.PI,func:e=>Math.sin(e/400)*Math.cos(e/1300)}];Promise.all(w.map((e=>M().setStart(0).setEnd(e.length).setStep(1).setSamplingFunction(e.func).generate().toPromise().then((e=>e.map((e=>e.y))))))).then((e=>{let t=window.performance.now(),n=0;const s=()=>{const a=window.performance.now(),o=Math.floor(1e3*(a-t)/1e3),i=Math.min(o-n,1e3),r=[];for(let t=0;t<S.length;t++){const s=e[t%e.length],a=[];for(let e=0;e<i;e++){const t={x:1*(n+e),y:s[(n+e)%s.length]};a.push(t)}r[t]=a}S.forEach(((e,t)=>e.series.add(r[t]))),n+=i,requestAnimationFrame(s)};s()}));let P=window.performance.now(),T=0,v=0;const C=x.chart.getTitle(),b=()=>{T++;const e=window.performance.now();v=1e3/((e-P)/T),requestAnimationFrame(b),x.chart.setTitle(`${C} (FPS: ${v.toFixed(1)})`)};requestAnimationFrame(b),setInterval((()=>{P=window.performance.now(),T=0}),5e3)}},e=>{e.O(0,[736],(()=>(138,e(e.s=138)))),e.O()}]);